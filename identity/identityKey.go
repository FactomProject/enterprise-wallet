// IdentityKey is able to maintain a list of AddressNamePairs, which consists of a public key,
// a name, and a boolean flag to indicate if it is a seeded key.
// The list is able to be marshaled into binary for saving.
package identity

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"strconv"
	"strings"

	"github.com/FactomProject/btcutil/base58"
	"github.com/FactomProject/factom"
)

var _ = fmt.Sprintf("")

// MaxNameLength is the longest a name is allowed to be.
const MaxNameLength int = 20

// IdentityKeyNamePair represents a public address to a user readable name. Also contains
// whether is was generated by the seed.
type IdentityKeyNamePair struct {
	Name    string // Length maxNameLength Characters
	Key     string
	Seeded  bool // Derived from seeed

	// Not Marshaled
	Balance int64 // Unused except for JSON return
}

// NewIdentityKey used if addresses DOES NOT derives from the seed
func NewIdentityKey(name string, k string) (*IdentityKeyNamePair, error) {
	if len(name) > MaxNameLength {
		return nil, fmt.Errorf("Name must be max %d characters", MaxNameLength)
	}

	err, _ := sanitize(name)
	if err != nil {
		return nil, err
	}
	// name = strings.Replace(name, " ", "_", -1)

	if !factom.IsValidIdentityKey(k) {
		return nil, errors.New("Identity key is invalid")
	}

	idKey := new(IdentityKeyNamePair)

	//var n [maxNameLength]byte
	//copy(n[:maxNameLength], name)

	idKey.Name = name
	idKey.Key = k
	idKey.Seeded = false

	return idKey, nil
}

var IllegalCharacters = `!@#$%^&*()+=';:.,?/*<>"'[]{}~|\ ` + "`"

func sanitize(str string) (error, string) {
	var err error
	badChars := ""
	notAllowed := strings.Split(IllegalCharacters, "")
	for _, na := range notAllowed {
		if strings.Contains(str, na) {
			badChars += na
			str = strings.Replace(str, na, "_", -1)
		}
	}
	if badChars != "" {
		err = fmt.Errorf("A name can only contain the following characters 'a-z, A-Z, 0-9, _ , -'\n The characters '%s' are not allowed", badChars)
	}

	return err, str
}

// NewSeededIdentityKey used if addresses derives from the seed
func NewSeededIdentityKey(name string, k string) (*IdentityKeyNamePair, error) {
	idKey, err := NewIdentityKey(name, k)
	if err != nil {
		return nil, err
	}

	idKey.Seeded = true
	return idKey, nil
}

// ChangeName should be used instead of manually changing the name, as ChangeName
// ensure the new name is of an appropriate length
func (idKey *IdentityKeyNamePair) ChangeName(name string) error {
	if len(name) > MaxNameLength {
		return fmt.Errorf("Name too long, must be less than %d characters", MaxNameLength)
	}

	err, _ := sanitize(name)
	if err != nil {
		return err
	}

	idKey.Name = name
	return nil
}

// IsSimilarTo will ONLY compare keys, not names or seeded.
func (idKey *IdentityKeyNamePair) IsSimilarTo(b *IdentityKeyNamePair) bool {
	if strings.Compare(idKey.Key, b.Key) != 0 {
		return false
	}

	return true
}

// IsSameAs will compare keys and names
func (idKey *IdentityKeyNamePair) IsSameAs(b *IdentityKeyNamePair) bool {
	if !idKey.IsSimilarTo(b) {
		return false
	}

	if strings.Compare(idKey.Name, b.Name) != 0 {
		return false
	}

	return true
}

// MarshalBinary will convert an IdentityKeyNamePair to a []byte, which can be unmarshaled
func (idKey *IdentityKeyNamePair) MarshalBinary() (data []byte, err error) {
	buf := new(bytes.Buffer)

	var n [MaxNameLength]byte
	copy(n[:MaxNameLength], idKey.Name)
	buf.Write(n[:MaxNameLength]) // 0:20

	add := base58.Decode(idKey.Key)
	var a [factom.IDKeyLength]byte
	copy(a[:factom.IDKeyLength], add[:])
	buf.Write(a[:factom.IDKeyLength]) // 20:61

	var b []byte
	b = strconv.AppendBool(b, idKey.Seeded)
	if idKey.Seeded {
		b = append(b, 0x00)
	}
	buf.Write(b) // 61:66

	return buf.Next(buf.Len()), nil
}

func (idKey *IdentityKeyNamePair) UnmarshalBinaryData(data []byte) (newData []byte, err error) {
	newData = data

	nameData := bytes.Trim(newData[:MaxNameLength], "\x00")
	idKey.Name = fmt.Sprintf("%s", nameData)
	newData = newData[MaxNameLength:]

	// Correct any bad names
	_, idKey.Name = sanitize(idKey.Name)
	// 	anp.Name = strings.Replace(anp.Name, " ", "_", -1)

	idKey.Key = base58.Encode(newData[:factom.IDKeyLength])
	newData = newData[factom.IDKeyLength:]

	booldata := newData[:5]
	if booldata[4] == 0x00 {
		booldata = booldata[:4]
	}
	b, err := strconv.ParseBool(string(booldata))
	if err != nil {
		return data, err
	}
	idKey.Seeded = b
	newData = newData[5:]

	return
}

func (idKey *IdentityKeyNamePair) UnmarshalBinary(data []byte) (err error) {
	_, err = idKey.UnmarshalBinaryData(data)
	return
}

type IdentityKeyList struct {
	Length uint64
	List   []IdentityKeyNamePair
}

func NewIdentityKeyList() *IdentityKeyList {
	idKeyList := new(IdentityKeyList)
	idKeyList.Length = 0

	return idKeyList
}

// Get searches for Identity Key by public key (not name) and returns the key/name pair struct and its
// corresponding index in the IdentityKeyList
func (idKeyList *IdentityKeyList) Get(key string) (*IdentityKeyNamePair, int) {
	if !factom.IsValidIdentityKey(key) {
		return nil, -1
	}

	for i, idKey := range idKeyList.List {
		if strings.Compare(idKey.Key, key) == 0 {
			return &idKey, i
		}
	}
	return nil, -1
}

// AddKeyNamePair ensures the identity key is valid and not a duplicate before it is added
func (idKeyList *IdentityKeyList) AddKeyNamePair(idKey *IdentityKeyNamePair) error {
	if len(idKey.Name) == 0 || !factom.IsValidAddress(idKey.Key) {
		return errors.New("nil IdentityKeyNamePar")
	}

	_, i := idKeyList.Get(idKey.Key)
	if i == -1 {
		idKeyList.List = append(idKeyList.List, *idKey)
		idKeyList.Length++
		return nil
	}

	// Duplicate Found
	return errors.New("Address or Name already exists")

}

// AddSeeded should be called when an identity key is seeded, as this will set the seeded flag
func (idKeyList *IdentityKeyList) AddSeeded(name string, key string) (*IdentityKeyNamePair, error) {
	idKey, err := NewSeededIdentityKey(name, key)
	if err != nil {
		return nil, err
	}
	return idKeyList.add(idKey)
}

// Add is called when an address is not seeded.
func (idKeyList *IdentityKeyList) Add(name string, key string) (*IdentityKeyNamePair, error) {
	idKey, err := NewIdentityKey(name, key)
	if err != nil {
		return nil, err
	}
	return idKeyList.add(idKey)
}

func (idKeyList *IdentityKeyList) add(idKey *IdentityKeyNamePair) (*IdentityKeyNamePair, error) {
	// We check for valid identity key higher up, this is just a basic check
	if len(idKey.Name) == 0 {
		return nil, errors.New("nil IdentityKeyNamePair or has no name. Name must be at least 1 character")
	}

	if len(idKey.Name) > MaxNameLength {
		idKey.Name = idKey.Name[:MaxNameLength]
	}

	_, i := idKeyList.Get(idKey.Key)
	if i == -1 {
		idKeyList.List = append(idKeyList.List, *idKey)
		idKeyList.Length++
		return idKey, nil
	}

	// Duplicate Found
	return nil, errors.New("identity key already exists")

}

func (idKeyList *IdentityKeyList) Remove(removeAdd string) error {
	_, i := idKeyList.Get(removeAdd)
	if i == -1 {
		return errors.New("identity key not found")
	}
	idKeyList.Length--
	idKeyList.List = append(idKeyList.List[:i], idKeyList.List[i+1:]...)

	return nil
}

// ResetSeeded is used when importing a new seed. This will set all addresses to be unseeded.
func (idKeyList *IdentityKeyList) ResetSeeded() {
	for i := range idKeyList.List {
		idKeyList.List[i].Seeded = false
	}
}

func (idKeyList *IdentityKeyList) MarshalBinary() (data []byte, err error) {
	buf := new(bytes.Buffer)
	var number [8]byte
	binary.BigEndian.PutUint64(number[:], idKeyList.Length)
	buf.Write(number[:])

	for _, idKey := range idKeyList.List {
		idKeyData, err := idKey.MarshalBinary()
		if err != nil {
			return nil, err
		}
		buf.Write(idKeyData)
	}

	return buf.Next(buf.Len()), err
}

func (idKeyList *IdentityKeyList) UnmarshalBinaryData(data []byte) (newData []byte, err error) {
	newData = data

	idKeyList.Length = binary.BigEndian.Uint64(data[:8])
	newData = newData[8:]

	var i uint64 = 0
	for i < idKeyList.Length {
		idKey := new(IdentityKeyNamePair)
		newData, err = idKey.UnmarshalBinaryData(newData)
		idKeyList.List = append(idKeyList.List, *idKey)
		i++
	}

	return
}

func (idKeyList *IdentityKeyList) UnmarshalBinary(data []byte) (err error) {
	_, err = idKeyList.UnmarshalBinaryData(data)
	return
}

// IsSameAs will call the IsSameAs for individual elemtents, meaning it will compare
// length, addresses, names, AND order
func (idKeyList *IdentityKeyList) IsSameAs(b *IdentityKeyList) bool {
	if idKeyList.Length != b.Length {
		return false
	}

	for _, aKey := range idKeyList.List {
		if bKey, i := b.Get(aKey.Key); i == -1 || !aKey.IsSameAs(bKey) {
			return false
		}
	}

	return true
}
